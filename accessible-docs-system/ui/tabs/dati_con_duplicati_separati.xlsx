"""
Images Tab - Scheda completa per gestione e editing immagini
Sostituisce la vecchia scheda images con funzionalità avanzate:
- Visualizzazione contesto (testo prima/dopo)
- Editor integrato (crop, rotate, replace)  
- Split tool (verticale, orizzontale, griglia, libero)
- Salvataggio diretto nel documento
"""

from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
                             QTextEdit, QSplitter, QListWidget, QListWidgetItem, 
                             QGroupBox, QToolBar, QMessageBox, QFileDialog, QSlider,
                             QComboBox, QSpinBox, QCheckBox, QFrame, QScrollArea)
from PyQt6.QtCore import Qt, QSize, pyqtSignal, QRect, QPoint
from PyQt6.QtGui import QPixmap, QImage, QPainter, QPen, QColor, QFont, QAction, QIcon
from PIL import Image
import io

from modules.image_editor.image_editor import ImageEditor
from modules.image_editor.image_splitter import ImageSplitter
from modules.image_editor.document_image_manager import DocumentImageManager
from ui.dialogs.split_naming_dialog import SplitNamingDialog


class InteractiveCanvas(QLabel):
    """Canvas interattivo per editing immagini"""
    
    # Signals
    area_selected = pyqtSignal(QRect)  # Emesso quando utente seleziona area
    split_line_moved = pyqtSignal(int)  # Emesso quando muove linea split
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setMinimumSize(400, 300)
        self.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.setStyleSheet("border: 2px solid #ccc; background: #f5f5f5;")
        
        # Stato
        self.mode = 'view'  # 'view', 'crop', 'split_v', 'split_h'
        self.current_pixmap = None
        self.original_image = None
        
        # Crop selection
        self.crop_start = None
        self.crop_current = None
        self.crop_rect = None
        
        # Split line
        self.split_position = None  # int - posizione linea split
        self.dragging_split = False
        
        self.setMouseTracking(True)
    
    def set_mode(self, mode: str):
        """Imposta modalità canvas"""
        self.mode = mode
        self.crop_start = None
        self.crop_current = None
        self.crop_rect = None
        self.split_position = None
        self.update()
    
    def load_image(self, pil_image: Image.Image):
        """Carica immagine PIL nel canvas"""
        self.original_image = pil_image.copy()
        self.display_image(pil_image)
    
    def display_image(self, pil_image: Image.Image):
        """Mostra immagine sul canvas"""
        # Converti PIL a QPixmap
        qimage = self._pil_to_qimage(pil_image)
        pixmap = QPixmap.fromImage(qimage)
        
        # Scala per fit nel canvas
        scaled = pixmap.scaled(
            self.size(),
            Qt.AspectRatioMode.KeepAspectRatio,
            Qt.TransformationMode.SmoothTransformation
        )
        
        self.current_pixmap = scaled
        self.setPixmap(scaled)
    
    def _pil_to_qimage(self, pil_image: Image.Image) -> QImage:
        """Converte PIL Image a QImage"""
        if pil_image.mode != 'RGB':
            pil_image = pil_image.convert('RGB')
        
        data = pil_image.tobytes('raw', 'RGB')
        qimage = QImage(data, pil_image.width, pil_image.height, 
                       pil_image.width * 3, QImage.Format.Format_RGB888)
        return qimage
    
    def paintEvent(self, event):
        """Override paint per disegnare overlays"""
        super().paintEvent(event)
        
        if not self.current_pixmap:
            return
        
        painter = QPainter(self)
        
        # Disegna crop rectangle
        if self.mode == 'crop' and self.crop_rect:
            pen = QPen(QColor(255, 0, 0), 2, Qt.PenStyle.DashLine)
            painter.setPen(pen)
            painter.drawRect(self.crop_rect)
            
            # Overlay semi-trasparente fuori selezione
            painter.fillRect(self.rect(), QColor(0, 0, 0, 100))
            painter.setCompositionMode(QPainter.CompositionMode.CompositionMode_Clear)
            painter.fillRect(self.crop_rect, Qt.GlobalColor.transparent)
        
        # Disegna linea split
        if self.mode in ['split_v', 'split_h'] and self.split_position is not None:
            pen = QPen(QColor(255, 0, 0), 3)
            painter.setPen(pen)
            
            pixmap_rect = self._get_pixmap_rect()
            
            if self.mode == 'split_v':
                # Linea orizzontale
                y = pixmap_rect.top() + self.split_position
                painter.drawLine(pixmap_rect.left(), y, pixmap_rect.right(), y)
            elif self.mode == 'split_h':
                # Linea verticale
                x = pixmap_rect.left() + self.split_position
                painter.drawLine(x, pixmap_rect.top(), x, pixmap_rect.bottom())
    
    def _get_pixmap_rect(self) -> QRect:
        """Ottiene rect dove è disegnato il pixmap"""
        if not self.current_pixmap:
            return QRect()
        
        # Il pixmap è centrato
        x = (self.width() - self.current_pixmap.width()) // 2
        y = (self.height() - self.current_pixmap.height()) // 2
        
        return QRect(x, y, self.current_pixmap.width(), self.current_pixmap.height())
    
    def mousePressEvent(self, event):
        """Handle mouse press per crop e split"""
        if event.button() != Qt.MouseButton.LeftButton:
            return
        
        pos = event.pos()
        pixmap_rect = self._get_pixmap_rect()
        
        if not pixmap_rect.contains(pos):
            return
        
        if self.mode == 'crop':
            self.crop_start = pos
            self.crop_current = pos
            self.crop_rect = QRect(pos, pos)
        
        elif self.mode in ['split_v', 'split_h']:
            # Check se vicino a linea esistente
            if self.split_position:
                if self.mode == 'split_v':
                    line_y = pixmap_rect.top() + self.split_position
                    if abs(pos.y() - line_y) < 10:
                        self.dragging_split = True
                elif self.mode == 'split_h':
                    line_x = pixmap_rect.left() + self.split_position
                    if abs(pos.x() - line_x) < 10:
                        self.dragging_split = True
            else:
                # Crea nuova linea
                if self.mode == 'split_v':
                    self.split_position = pos.y() - pixmap_rect.top()
                elif self.mode == 'split_h':
                    self.split_position = pos.x() - pixmap_rect.left()
                self.update()
    
    def mouseMoveEvent(self, event):
        """Handle mouse move per crop drag e split"""
        if self.mode == 'crop' and self.crop_start:
            self.crop_current = event.pos()
            self.crop_rect = QRect(self.crop_start, self.crop_current).normalized()
            self.update()
        
        elif self.mode in ['split_v', 'split_h'] and self.dragging_split:
            pixmap_rect = self._get_pixmap_rect()
            
            if self.mode == 'split_v':
                new_pos = event.pos().y() - pixmap_rect.top()
                new_pos = max(10, min(pixmap_rect.height() - 10, new_pos))
                self.split_position = new_pos
            elif self.mode == 'split_h':
                new_pos = event.pos().x() - pixmap_rect.left()
                new_pos = max(10, min(pixmap_rect.width() - 10, new_pos))
                self.split_position = new_pos
            
            self.update()
            self.split_line_moved.emit(self.split_position)
    
    def mouseReleaseEvent(self, event):
        """Handle mouse release"""
        if event.button() != Qt.MouseButton.LeftButton:
            return
        
        if self.mode == 'crop' and self.crop_rect:
            # Converti crop rect da coordinate widget a coordinate immagine
            pixmap_rect = self._get_pixmap_rect()
            
            if pixmap_rect.intersects(self.crop_rect):
                # Scala coordinate
                scale_x = self.original_image.width / pixmap_rect.width()
                scale_y = self.original_image.height / pixmap_rect.height()
                
                rel_rect = self.crop_rect.translated(-pixmap_rect.topLeft())
                
                image_rect = QRect(
                    int(rel_rect.x() * scale_x),
                    int(rel_rect.y() * scale_y),
                    int(rel_rect.width() * scale_x),
                    int(rel_rect.height() * scale_y)
                )
                
                self.area_selected.emit(image_rect)
        
        elif self.mode in ['split_v', 'split_h'] and self.dragging_split:
            self.dragging_split = False
            self.split_line_moved.emit(self.split_position)
    
    def get_split_position_scaled(self) -> int:
        """Ritorna posizione split scalata alle dimensioni immagine originale"""
        if not self.split_position or not self.original_image:
            return 0
        
        pixmap_rect = self._get_pixmap_rect()
        
        if self.mode == 'split_v':
            scale = self.original_image.height / pixmap_rect.height()
            return int(self.split_position * scale)
        elif self.mode == 'split_h':
            scale = self.original_image.width / pixmap_rect.width()
            return int(self.split_position * scale)
        
        return 0


class ImagesTab(QWidget):
    """Scheda completa per gestione immagini con editor integrato"""
    
    def __init__(self, main_window):
        super().__init__()
        self.main_window = main_window
        self.images_data = []
        self.current_image = None
        self.current_metadata = None
        self.editor = None
        self.document_manager = None
        
        self.init_ui()
    
    def init_ui(self):
        """Inizializza UI"""
        layout = QHBoxLayout()
        
        # Splitter principale
        splitter = QSplitter(Qt.Orientation.Horizontal)
        
        # Pannello sinistro - Lista immagini
        left_panel = self.create_images_list_panel()
        splitter.addWidget(left_panel)
        
        # Pannello centrale - Viewer/Editor a 3 sezioni
        center_panel = self.create_viewer_panel()
        splitter.addWidget(center_panel)
        
        splitter.setSizes([250, 750])
        layout.addWidget(splitter)
        
        self.setLayout(layout)
    
    def create_images_list_panel(self):
        """Crea pannello lista immagini"""
        panel = QWidget()
        layout = QVBoxLayout()
        
        title = QLabel("📷 Immagini")
        title.setFont(QFont('Arial', 12, QFont.Weight.Bold))
        layout.addWidget(title)
        
        # Filtri
        filters_group = QGroupBox("Filtri")
        filters_layout = QVBoxLayout()
        
        self.filter_with_alt = QCheckBox("Con testo alternativo")
        self.filter_with_alt.stateChanged.connect(self.apply_filters)
        filters_layout.addWidget(self.filter_with_alt)
        
        self.filter_without_alt = QCheckBox("Senza testo alternativo")
        self.filter_without_alt.setChecked(True)
        self.filter_without_alt.stateChanged.connect(self.apply_filters)
        filters_layout.addWidget(self.filter_without_alt)
        
        filters_group.setLayout(filters_layout)
        layout.addWidget(filters_group)
        
        # Lista immagini
        self.images_list = QListWidget()
        self.images_list.itemClicked.connect(self.on_image_selected)
        layout.addWidget(self.images_list)
        
        # Stats
        self.stats_label = QLabel("0 immagini")
        self.stats_label.setStyleSheet("color: #666; font-size: 9pt;")
        layout.addWidget(self.stats_label)
        
        # Pulsante refresh
        btn_refresh = QPushButton("🔄 Aggiorna Lista")
        btn_refresh.clicked.connect(self.load_images_from_document)
        layout.addWidget(btn_refresh)
        
        panel.setLayout(layout)
        return panel
    
    # Continua in PARTE 2...

    def create_viewer_panel(self):
        """Crea pannello viewer a 3 sezioni con toolbar"""
        panel = QWidget()
        layout = QVBoxLayout()
        
        # === TOOLBAR EDITING ===
        toolbar = QToolBar()
        toolbar.setIconSize(QSize(32, 32))
        
        # Split tools
        self.action_split_v = toolbar.addAction("✂️ Split V", self.start_split_vertical)
        self.action_split_h = toolbar.addAction("✂️ Split H", self.start_split_horizontal)
        self.action_split_grid = toolbar.addAction("⊞ Grid", self.start_split_grid)
        self.action_split_free = toolbar.addAction("✏️ Free", self.start_split_free)
        
        toolbar.addSeparator()
        
        # Edit tools
        self.action_crop = toolbar.addAction("✂️ Crop", self.start_crop)
        self.action_rotate = toolbar.addAction("🔄 Rotate", self.show_rotate_options)
        self.action_replace = toolbar.addAction("📂 Replace", self.replace_image)
        
        toolbar.addSeparator()
        
        # Actions
        self.action_undo = toolbar.addAction("↩️ Undo", self.undo_edit)
        self.action_preview = toolbar.addAction("👁️ Preview", self.preview_changes)
        self.action_save = toolbar.addAction("💾 Save", self.save_to_document)
        
        # Inizialmente disabilita toolbar
        self.set_toolbar_enabled(False)
        
        layout.addWidget(toolbar)
        
        # === SPLITTER 3 SEZIONI ===
        sections_splitter = QSplitter(Qt.Orientation.Vertical)
        
        # Sezione 1: Testo prima
        context_before_group = QGroupBox("📄 Testo Prima (Context Before)")
        context_before_layout = QVBoxLayout()
        self.context_before_text = QTextEdit()
        self.context_before_text.setReadOnly(True)
        self.context_before_text.setMaximumHeight(120)
        context_before_layout.addWidget(self.context_before_text)
        context_before_group.setLayout(context_before_layout)
        sections_splitter.addWidget(context_before_group)
        
        # Sezione 2: Immagine/Canvas centrale
        image_group = QGroupBox("🖼️ Immagine")
        image_layout = QVBoxLayout()
        
        # Canvas interattivo
        self.canvas = InteractiveCanvas()
        self.canvas.area_selected.connect(self.on_crop_area_selected)
        self.canvas.split_line_moved.connect(self.on_split_line_moved)
        image_layout.addWidget(self.canvas)
        
        # Info immagine
        self.image_info_label = QLabel("Nessuna immagine selezionata")
        self.image_info_label.setStyleSheet("color: #666; padding: 5px;")
        image_layout.addWidget(self.image_info_label)
        
        image_group.setLayout(image_layout)
        sections_splitter.addWidget(image_group)
        
        # Sezione 3: Testo dopo
        context_after_group = QGroupBox("📄 Testo Dopo (Context After)")
        context_after_layout = QVBoxLayout()
        self.context_after_text = QTextEdit()
        self.context_after_text.setReadOnly(True)
        self.context_after_text.setMaximumHeight(120)
        context_after_layout.addWidget(self.context_after_text)
        context_after_group.setLayout(context_after_layout)
        sections_splitter.addWidget(context_after_group)
        
        sections_splitter.setSizes([100, 400, 100])
        layout.addWidget(sections_splitter)
        
        panel.setLayout(layout)
        return panel
    
    def set_toolbar_enabled(self, enabled: bool):
        """Abilita/disabilita toolbar"""
        self.action_split_v.setEnabled(enabled)
        self.action_split_h.setEnabled(enabled)
        self.action_split_grid.setEnabled(enabled)
        self.action_split_free.setEnabled(enabled)
        self.action_crop.setEnabled(enabled)
        self.action_rotate.setEnabled(enabled)
        self.action_replace.setEnabled(enabled)
        self.action_undo.setEnabled(enabled)
        self.action_preview.setEnabled(enabled)
        self.action_save.setEnabled(enabled)
    
    def load_images_from_document(self):
        """Carica tutte le immagini dal documento"""
        if not hasattr(self.main_window, 'analyzer') or not self.main_window.analyzer:
            QMessageBox.warning(self, "Errore", "Nessun documento caricato")
            return
        
        doc = self.main_window.analyzer.document
        self.document_manager = DocumentImageManager(doc)
        
        self.images_data = self.document_manager.get_all_images_with_positions()
        self.apply_filters()
    
    def apply_filters(self):
        """Applica filtri e aggiorna lista"""
        self.images_list.clear()
        
        for img_data in self.images_data:
            # TODO: Implementa filtro alt text quando disponibile
            item = QListWidgetItem(f"📷 Par.{img_data['paragraph_index']}")
            item.setData(Qt.ItemDataRole.UserRole, img_data)
            self.images_list.addItem(item)
        
        self.stats_label.setText(f"{len(self.images_data)} immagini")
    
    def on_image_selected(self, item):
        """Handler selezione immagine"""
        img_data = item.data(Qt.ItemDataRole.UserRole)
        if not img_data:
            return
        
        self.current_image = img_data['image']
        self.current_metadata = img_data['metadata']
        
        # Carica immagine nel canvas
        self.canvas.load_image(self.current_image)
        
        # Inizializza editor
        self.editor = ImageEditor(self.current_image)
        
        # Abilita toolbar
        self.set_toolbar_enabled(True)
        
        # Aggiorna info
        info = f"Dimensioni: {self.current_image.width}x{self.current_image.height}px | " \
               f"Formato: {self.current_metadata.get('format', 'N/A')} | " \
               f"Paragrafo: {self.current_metadata['paragraph_index']}"
        self.image_info_label.setText(info)
        
        # Carica contesto
        self.load_context_text(self.current_metadata['paragraph_index'])
    
    def load_context_text(self, paragraph_index: int):
        """Carica testo prima e dopo l'immagine"""
        if not hasattr(self.main_window, 'analyzer') or not self.main_window.analyzer:
            return
        
        doc = self.main_window.analyzer.document
        paragraphs = doc.paragraphs
        
        # Testo prima (5 paragrafi)
        before_text = []
        for i in range(max(0, paragraph_index - 5), paragraph_index):
            if i < len(paragraphs):
                text = paragraphs[i].text.strip()
                if text:
                    before_text.append(text)
        self.context_before_text.setText('\n\n'.join(before_text))
        
        # Testo dopo (5 paragrafi)
        after_text = []
        for i in range(paragraph_index + 1, min(len(paragraphs), paragraph_index + 6)):
            text = paragraphs[i].text.strip()
            if text:
                after_text.append(text)
        self.context_after_text.setText('\n\n'.join(after_text))
    
    # === SPLIT HANDLERS ===
    
    def start_split_vertical(self):
        """Avvia modalità split verticale"""
        if not self.current_image:
            return
        self.canvas.set_mode('split_v')
        # Posizione iniziale al centro
        self.canvas.split_position = self.canvas.current_pixmap.height() // 2
        self.canvas.update()
    
    def start_split_horizontal(self):
        """Avvia modalità split orizzontale"""
        if not self.current_image:
            return
        self.canvas.set_mode('split_h')
        # Posizione iniziale al centro
        self.canvas.split_position = self.canvas.current_pixmap.width() // 2
        self.canvas.update()
    
    def start_split_grid(self):
        """Avvia split griglia"""
        if not self.current_image:
            return
        
        # Dialog per chiedere dimensioni griglia
        from PyQt6.QtWidgets import QInputDialog
        
        rows, ok1 = QInputDialog.getInt(self, "Split Griglia", "Numero righe:", 2, 1, 10)
        if not ok1:
            return
        
        cols, ok2 = QInputDialog.getInt(self, "Split Griglia", "Numero colonne:", 2, 1, 10)
        if not ok2:
            return
        
        # Esegui split
        splitter = ImageSplitter(self.current_image)
        parts = splitter.split_grid(rows, cols)
        
        # Dialog naming
        self.execute_split_with_naming(parts, f"Par.{self.current_metadata['paragraph_index']}")
    
    def start_split_free(self):
        """Split libero - non implementato in questa versione"""
        QMessageBox.information(
            self,
            "Split Libero",
            "Funzionalità Split Libero in arrivo!\n\n"
            "Per ora usa Split Verticale/Orizzontale o Griglia."
        )
    
    def on_split_line_moved(self, position: int):
        """Handler movimento linea split"""
        # Solo aggiorna visualizzazione
        pass
    
    def preview_split(self):
        """Preview split corrente"""
        if not self.current_image or self.canvas.mode not in ['split_v', 'split_h']:
            return
        
        pos_scaled = self.canvas.get_split_position_scaled()
        if pos_scaled == 0:
            return
        
        splitter = ImageSplitter(self.current_image)
        
        if self.canvas.mode == 'split_v':
            parts = splitter.split_vertical(pos_scaled)
        else:
            parts = splitter.split_horizontal(pos_scaled)
        
        # Esegui split
        self.execute_split_with_naming(parts, f"Par.{self.current_metadata['paragraph_index']}")
    
    def execute_split_with_naming(self, parts: list, original_label: str):
        """Esegue split chiedendo nomi"""
        # Dialog per naming
        dialog = SplitNamingDialog(parts, original_label, self)
        
        if dialog.exec() != dialog.DialogCode.Accepted:
            return
        
        names = dialog.get_part_names()
        
        # Salva nel documento
        if self.document_manager:
            # Backup automatico
            self.document_manager.backup_image(self.current_metadata['paragraph_index'])
            
            # Inserisci parti
            indices = self.document_manager.split_and_insert(
                self.current_metadata['paragraph_index'],
                parts,
                names
            )
            
            QMessageBox.information(
                self,
                "Split Completato",
                f"Immagine divisa in {len(parts)} parti:\n" +
                '\n'.join(f"• {name}" for name in names)
            )
            
            # Refresh lista
            self.load_images_from_document()
    
    # === EDIT HANDLERS ===
    
    def start_crop(self):
        """Avvia modalità crop"""
        if not self.current_image:
            return
        self.canvas.set_mode('crop')
    
    def on_crop_area_selected(self, rect: QRect):
        """Handler selezione area crop"""
        if not self.editor:
            return
        
        # Esegui crop
        box = (rect.x(), rect.y(), rect.right(), rect.bottom())
        cropped = self.editor.crop(box)
        
        # Aggiorna display
        self.canvas.display_image(cropped)
        self.canvas.set_mode('view')
    
    def show_rotate_options(self):
        """Mostra opzioni rotazione"""
        if not self.editor:
            return
        
        from PyQt6.QtWidgets import QInputDialog
        
        angles = ["90° Orario", "180°", "270° Orario (90° Antiorario)"]
        choice, ok = QInputDialog.getItem(self, "Rotazione", "Scegli angolo:", angles, 0, False)
        
        if not ok:
            return
        
        if "90°" in choice and "270" not in choice:
            angle = 90
        elif "180" in choice:
            angle = 180
        else:
            angle = 270
        
        rotated = self.editor.rotate(angle)
        self.canvas.display_image(rotated)
    
    def replace_image(self):
        """Sostituisci immagine da file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Seleziona Immagine",
            "",
            "Immagini (*.png *.jpg *.jpeg *.bmp *.gif)"
        )
        
        if not file_path:
            return
        
        # Carica nuova immagine
        new_image = Image.open(file_path)
        
        # Aggiorna editor e display
        self.editor = ImageEditor(new_image)
        self.canvas.load_image(new_image)
        
        QMessageBox.information(self, "Immagine Sostituita", "Immagine caricata. Usa 'Save' per applicare al documento.")
    
    def undo_edit(self):
        """Annulla ultima modifica"""
        if not self.editor:
            return
        
        undone = self.editor.undo()
        if undone:
            self.canvas.display_image(undone)
    
    def preview_changes(self):
        """Preview modifiche"""
        if self.canvas.mode == 'split_v' or self.canvas.mode == 'split_h':
            self.preview_split()
        else:
            QMessageBox.information(self, "Preview", "Le modifiche sono già visibili nel canvas")
    
    def save_to_document(self):
        """Salva modifiche nel documento"""
        if not self.editor or not self.document_manager:
            QMessageBox.warning(self, "Errore", "Nessuna modifica da salvare")
            return
        
        reply = QMessageBox.question(
            self,
            "Conferma Salvataggio",
            "Salvare le modifiche nel documento?\n\n"
            "Un backup dell'originale è stato creato automaticamente.",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if reply != QMessageBox.StandardButton.Yes:
            return
        
        # Ottieni immagine corrente dall'editor
        current = self.editor.get_current_image()
        
        # Sostituisci nel documento
        success = self.document_manager.replace_image(
            self.current_metadata['paragraph_index'],
            current,
            self.current_metadata.get('run_index', 0)
        )
        
        if success:
            QMessageBox.information(self, "Successo", "Immagine salvata nel documento!")
            self.load_images_from_document()
        else:
            QMessageBox.warning(self, "Errore", "Impossibile salvare l'immagine")
